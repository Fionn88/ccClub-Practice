"""
二元搜索
描述

大家有沒有發現，生活中有很多東西，往往會以排序好的方式存放呢？
舉例來說，在圖書館裡面，書目會按照索書號會由小到大存放，除了有個規則可以依循方便我們存放東西之外，按順序排好的方式存放，可以節省我們查找的時間 -- 只要你用對方法！在這裡，我們介紹一下二元搜索：

針對一個排序好的數列，我們可以靠著二元搜索來節省尋找特定數字的時間，想法如下：

取這個數列的中點，看他等不等於想要找的數字，如果等於就回傳該數字與相關的資訊。
如果不等於就判斷這個中點的數值是大於還小於目標數值，如果大於，那就往左半邊的數列再執行一次一樣的動作，反之如果小於，就往右半邊的數列執行一次一樣的動作，直到找到該數字為止。
現在，給定一個排序過的書目列表，請你設計一個可以協助找到對應索書號的書名的演算法，若沒有這個書目則輸出not found，可以試試看用新教的遞迴方式寫這一題喔！


輸入
輸入有三行。
第一行代表排序後的索書號，以空格區隔。
第二行代表對應的書籍名稱，以空格區隔。
第三行代表想要查找的索書號。


輸出
輸出有一行，為找到的書籍名稱，若沒有這個書目則輸出 "not found"。


輸入範例 1 
1110 1112 1113 1115 1116 1117 1118 1119 1130 1134 1138 1152
初級會計學 中級會計學 高等會計學 審計學 成本與管理會計 稅務法規 民法概要 企業管理 財務管理 經濟學原理 統計學 微積分
1134

輸出範例 1
經濟學原理

輸入範例 2 
1 2 3 5 8 13 21 34 55
A B C D E F G H I J
14

輸出範例 2
not found
"""

code = list(map(int,input().split()))
name = input().split()
search = int(input())

def binary_search(code, key):
    #設置選取範圍的指標
    low = 0
    upper = len(code) - 1
    while low <= upper:
        mid = (low + upper) // 2  #取中間索引的值
        if code[mid] < key:    #若搜尋值比中間的值大，將中間索引+1，取右半
            low = mid + 1
        elif code[mid] > key:  #若搜尋值比中間的值小，將中間索引+1，取左半
            upper = mid - 1
        else:                    #若搜尋值等於中間的值，則回傳
            return mid
    return -1

index = binary_search(code, search)
if index >= 0:
    print(name[index])
else:
    print("not found")
    